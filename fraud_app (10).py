# -*- coding: utf-8 -*-
"""fraud_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xa9IT3yQfQa6fl9GZlMPAGdHdPaz4Qu8
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
import io
from sklearn.feature_extraction.text import TfidfVectorizer
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_recall_curve
from imblearn.over_sampling import SMOTE
from scipy.sparse import hstack
import matplotlib.pyplot as plt

# --- PAGE CONFIG ---
st.set_page_config(page_title="üéØ Fraud Job Detector", layout="wide")

# --- CUSTOM STYLING ---
st.markdown("""
    <style>
    .main {
        background-color: #0e1117;
        color: #ffffff;
    }
    .block-container {
        padding: 2rem;
        background-color: #0e1117;
    }
    h1 {
        text-align: center;
        color: #00a8ff;
        border-bottom: 2px solid #00a8ff;
        padding-bottom: 10px;
    }
    .css-1d391kg p {
        text-align: center;
        font-size: 18px;
        color: #a9a9a9;
    }
    .st-b7, .st-cb, .st-bb, .stSidebar {
        background-color: #1a1d23 !important;
    }
    .stDownloadButton button {
        background-color: #00a8ff !important;
        color: white !important;
        border: none !important;
        font-weight: bold;
    }
    .stDataFrame {
        background-color: #1a1d23 !important;
        color: #ffffff !important;
    }
    .stAlert {
        background-color: #1a1d23 !important;
        color: #ffffff !important;
    }
    .stMarkdown small {
        color: #6c757d !important;
    }
    .stButton button {
        background-color: #00a8ff !important;
        color: white !important;
        border: none !important;
    }
    .stFileUploader label {
        color: #00a8ff !important;
    }
    /* Card styles for Why Choose section */
    .feature-card {
        background: #fff;
        border-radius: 18px;
        box-shadow: 0 2px 12px 0 rgba(60,60,60,0.07);
        padding: 24px 20px 20px 20px;
        margin-bottom: 20px;
        min-height: 160px;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    .feature-icon {
        font-size: 36px;
        margin-bottom: 8px;
    }
    .feature-title {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: 6px;
        color: #222;
    }
    .feature-desc {
        font-size: 15px;
        color: #555;
    }
    </style>
""", unsafe_allow_html=True)

# --- SIDEBAR STYLING ---
st.sidebar.markdown("""
    <style>
    .css-1vq4p4l {
        background-color: #1a1d23 !important;
    }
    .css-1hynsf2 {
        color: #00a8ff !important;
    }
    </style>
""", unsafe_allow_html=True)

# --- HEADER ---
st.markdown("""
# üïµÔ∏è‚Äç‚ôÇÔ∏è AI-Powered Job Fraud Detection
Detect potentially fraudulent job postings using intelligent machine learning
---
""")

# --- DATA LOADING ---
@st.cache_data
def load_data():
    file_id = "1oxygynnHOAU3NU3S8xHRdBS9WA_K1E7y"
    url = f"https://drive.google.com/uc?id={file_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        train_df = pd.read_csv(io.BytesIO(response.content))
    except Exception as e:
        st.error(f"Error loading training data from Google Drive: {e}")
        train_df = pd.DataFrame()
    return train_df

# --- DATA PREPARATION ---
@st.cache_data
def prepare(df):
    df = df.copy()
    for col in ['title', 'description', 'requirements', 'company_profile']:
        if col not in df.columns:
            df[col] = ''
        else:
            df[col] = df[col].fillna('')
    # Only handle 'email' if it exists
    if 'email' in df.columns:
        df['email'] = df['email'].fillna('')
        df['email_domain'] = df['email'].apply(lambda x: x.split('@')[-1] if '@' in x else '')
        df['free_email'] = df['email_domain'].isin(['gmail.com', 'yahoo.com', 'hotmail.com']).astype(int)
    else:
        df['email_domain'] = ''
        df['free_email'] = 0
    df['text'] = (
        df['title'] + ' ' +
        df['description'] + ' ' +
        df['requirements'] + ' ' +
        df['company_profile']
    )
    df['desc_len'] = df['description'].apply(len)
    df['word_count'] = df['description'].apply(lambda x: len(x.split()))
    df['num_digits_in_title'] = df['title'].apply(lambda x: sum(c.isdigit() for c in x))
    df['has_profile'] = (df['company_profile'] != '').astype(int)
    suspicious_words = ['money', 'wire', 'bitcoin', 'transfer', 'click']
    df['suspicious_terms'] = df['description'].apply(
        lambda x: int(any(term in x.lower() for term in suspicious_words))
    )
    return df

# --- MODEL TRAINING ---
@st.cache_resource
def train_model(train_df):
    if train_df.empty:
        st.warning("Training data not loaded. Model training skipped.")
        return None, None, 0.5
    X = train_df[['text', 'desc_len', 'word_count', 'num_digits_in_title', 'has_profile', 'suspicious_terms', 'free_email']]
    y = train_df['fraudulent']
    tfidf = TfidfVectorizer(max_features=5000, stop_words='english')
    X_tfidf = tfidf.fit_transform(X['text'])
    X_combined = hstack([X_tfidf, X.drop(columns='text').values])
    X_train, X_val, y_train, y_val = train_test_split(X_combined, y, test_size=0.2, stratify=y, random_state=42)
    X_res, y_res = SMOTE(random_state=42).fit_resample(X_train, y_train)
    model = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)
    model.fit(X_res, y_res)
    val_probs = model.predict_proba(X_val)[:, 1]
    p, r, thresholds = precision_recall_curve(y_val, val_probs)
    f1s = 2 * p * r / (p + r + 1e-6)
    best_threshold = thresholds[np.argmax(f1s)]
    return model, tfidf, best_threshold

# --- MAIN FLOW ---
train_df = load_data()
if not train_df.empty:
    train_df = prepare(train_df)
model, tfidf, best_threshold = train_model(train_df)

# --- SIDEBAR UPLOAD ---
uploaded_file = st.sidebar.file_uploader("üì§ Upload a CSV file for prediction", type="csv")
if uploaded_file is not None:
    try:
        test_df = pd.read_csv(uploaded_file)
        test_df = prepare(test_df)
        if model is not None and tfidf is not None:
            X_test = test_df[['text', 'desc_len', 'word_count', 'num_digits_in_title', 'has_profile', 'suspicious_terms', 'free_email']]
            X_test_tfidf = tfidf.transform(X_test['text'])
            X_test_combined = hstack([X_test_tfidf, X_test.drop(columns='text').values])
            test_df['fraud_probability'] = model.predict_proba(X_test_combined)[:, 1]
            test_df['fraud_predicted'] = (test_df['fraud_probability'] >= best_threshold).astype(int)
            st.success("‚úÖ Predictions generated successfully!")
            st.markdown("### üìã Job Predictions")
            st.dataframe(
                test_df[['title', 'location', 'fraud_probability', 'fraud_predicted']].sort_values(by='fraud_probability', ascending=False),
                use_container_width=True
            )
            st.download_button(
                "üì• Download Results as CSV",
                data=test_df.to_csv(index=False).encode(),
                file_name="fraud_predictions.csv",
                mime="text/csv"
            )
            # --- VISUALIZATION 1: HISTOGRAM (smaller size) ---
            st.markdown("### üìä Probability Distribution")
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                fig, ax = plt.subplots(figsize=(4,2.5))
                ax.hist(test_df['fraud_probability'], bins=20, color='#00a8ff', edgecolor='#1a1d23')
                ax.set_xlabel("Fraud Probability", color='white')
                ax.set_ylabel("Job Count", color='white')
                ax.tick_params(colors='white')
                ax.set_facecolor('#0e1117')
                fig.patch.set_facecolor('#0e1117')
                st.pyplot(fig)
            # --- VISUALIZATION 2: PIE CHART (smaller size) ---
            st.markdown("### üßÆ Fraud Prediction Breakdown")
            with col2:
                fraud_counts = test_df['fraud_predicted'].value_counts()
                labels = ['Not Fraud', 'Fraud']
                sizes = [fraud_counts.get(0, 0), fraud_counts.get(1, 0)]
                fig2, ax2 = plt.subplots(figsize=(3.5,2.5))
                ax2.pie(sizes, labels=labels, autopct='%1.1f%%',
                        colors=['#00a8ff', '#ff6b6b'], startangle=90,
                        textprops={'color': 'white'})
                ax2.axis('equal')
                fig2.patch.set_facecolor('#0e1117')
                st.pyplot(fig2)
        else:
            st.warning("Model not loaded. Cannot generate predictions.")
    except Exception as e:
        st.error(f"Error processing uploaded file: {e}")
else:
    st.info("üëà Upload a CSV file from the sidebar to begin analysis.")

# --- WHY CHOOSE OUR AI SOLUTION SECTION ---
st.markdown("---")
st.markdown(
    "<h2 style='text-align:center; margin-bottom:0;'>üöÄ Why Choose Our AI Solution?</h2>",
    unsafe_allow_html=True
)
st.markdown(
    "<p style='text-align:center; color:#555; font-size:18px; margin-top:0;'>"
    "Built with cutting-edge technology, our solution combines the power of machine learning with user-friendly design to tackle job fraud at scale."
    "</p>",
    unsafe_allow_html=True
)
card_icons = [
    "üõ°Ô∏è", "‚ö°", "üìä",
    "üßë‚Äçüíº", "üëÅÔ∏è", "‚úÖ"
]
card_titles = [
    "Advanced Fraud Detection",
    "Lightning Fast Analysis",
    "Detailed Analytics",
    "Protect Job Seekers",
    "Real-time Monitoring",
    "High Accuracy Rate"
]
card_descs = [
    "Our AI model analyzes multiple data points to identify suspicious job postings with high accuracy.",
    "Get results in seconds, not hours. Process thousands of job postings instantly.",
    "Comprehensive reports with fraud probability scores and detailed explanations.",
    "Help millions of job seekers avoid scams and find legitimate opportunities.",
    "Continuous monitoring of job posting platforms to detect threats proactively.",
    "Achieved 95%+ accuracy in fraud detection through advanced learning techniques."
]
# Display as 3 columns per row
for i in range(0, len(card_titles), 3):
    cols = st.columns(3)
    for j, col in enumerate(cols):
        if i+j < len(card_titles):
            col.markdown(
                f"""
                <div class="feature-card">
                    <div class="feature-icon">{card_icons[i+j]}</div>
                    <div class="feature-title">{card_titles[i+j]}</div>
                    <div class="feature-desc">{card_descs[i+j]}</div>
                </div>
                """, unsafe_allow_html=True
            )

# --- FOOTER ---
st.markdown("---")
st.markdown("<small style='color: #6c757d'>üöÄ Developed with ‚ù§Ô∏è using Streamlit</small>", unsafe_allow_html=True)